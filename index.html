<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Roblox-Style Tycoon (HTML/CSS/JS, Single File)</title>
<style>
  :root{
    --bg:#0b1025; --panel:#0f172a; --card:#111827; --muted:#94a3b8; --text:#e5e7eb;
    --accent:#22c55e; --accent2:#38bdf8; --warn:#f59e0b; --danger:#ef4444;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:linear-gradient(180deg,#0b1025,#0f172a 40%);color:var(--text);font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
  #hud{position:fixed;inset:0;pointer-events:none}
  .topbar{position:absolute;left:12px;top:10px;display:flex;gap:12px;align-items:center;pointer-events:auto}
  .badge{background:rgba(17,24,39,.7);border:1px solid #1f253d;padding:8px 12px;border-radius:10px;box-shadow:0 6px 20px rgba(0,0,0,.35);font-variant-numeric:tabular-nums}
  .money{font-weight:700;font-size:18px}
  .mult{opacity:.9}
  .btn{background:#0b132a;border:1px solid #1f2b52;padding:8px 12px;border-radius:10px;color:#cfe8ff;cursor:pointer;user-select:none}
  .btn:hover{background:#0e1733}
  .btn:disabled{opacity:.5;cursor:not-allowed}
  .panel{position:absolute;right:12px;top:10px;width:320px;max-height:90vh;overflow:auto;padding:10px;background:rgba(17,24,39,.7);border:1px solid #1f253d;border-radius:16px;box-shadow:0 20px 50px rgba(0,0,0,.35);pointer-events:auto}
  .panel h3{margin:6px 0 8px 0;font-size:16px;letter-spacing:.3px}
  .row{display:flex;gap:8px;align-items:center;justify-content:space-between;margin:6px 0}
  .pill{display:flex;gap:8px;align-items:center;background:#0b132a;border:1px solid #1f2b52;padding:8px 10px;border-radius:999px}
  .buy{background:#1d3a22;border:1px solid #2c6a3a;color:#d7ffe0}
  .buy:hover{background:#214227}
  .danger{background:#3a1d1d;border:1px solid #6a2c2c;color:#ffd7d7}
  .grid-toggle{margin-left:8px}
  .minimap{position:absolute;left:12px;bottom:12px;width:180px;height:180px;border-radius:12px;border:1px solid #1f253d;background:rgba(17,24,39,.7);box-shadow:0 10px 30px rgba(0,0,0,.35);pointer-events:auto}
  .hint{position:absolute;left:50%;bottom:12px;transform:translateX(-50%);background:rgba(17,24,39,.7);border:1px solid #1f253d;padding:8px 12px;border-radius:10px;box-shadow:0 10px 30px rgba(0,0,0,.35);pointer-events:auto;font-size:13px}
  .place-tooltip{position:absolute;transform:translate(-50%, -130%);background:#111827;padding:6px 8px;border:1px solid #263247;border-radius:8px;font-size:12px;white-space:nowrap}
  .toast{position:absolute;right:12px;bottom:12px;background:#111827;border:1px solid #263247;padding:8px 10px;border-radius:10px;box-shadow:0 10px 30px rgba(0,0,0,.35);pointer-events:auto;max-width:360px}
  canvas{display:block;outline:none}
</style>
</head>
<body>
  <!-- Three.js core -->
<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>

<!-- OrbitControls -->
<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/controls/OrbitControls.js"></script>
<div id="hud">
  <div class="topbar">
    <div class="badge money">üí∞ <span id="money">0</span></div>
    <div class="badge mult">üéñÔ∏è Mult: <span id="mult">1.0x</span></div>
    <button class="btn" id="saveBtn" title="Save to localStorage">Save</button>
    <button class="btn" id="loadBtn" title="Load from localStorage">Load</button>
  </div>

  <div class="panel" id="shopPanel">
    <h3>üõí Shop</h3>
    <div class="row"><div class="pill">‚ûï Basic Dropper (Tier 1)</div><button class="btn buy" id="buyDropper1"></button></div>
    <div class="row"><div class="pill">‚öôÔ∏è Conveyor Segment</div><button class="btn buy" id="buyConveyor"></button></div>
    <div class="row"><div class="pill">üöÄ Conveyor Speed</div><button class="btn buy" id="buySpeed"></button></div>
    <div class="row"><div class="pill">üíé Advanced Dropper (Tier 2)</div><button class="btn buy" id="buyDropper2"></button></div>
    <div class="row"><div class="pill">üî• Elite Dropper (Tier 3)</div><button class="btn buy" id="buyDropper3"></button></div>
    <div class="row"><div class="pill">üß† Hire Worker (auto-fix stuck items)</div><button class="btn buy" id="buyWorker"></button></div>

    <h3>‚öôÔ∏è Settings</h3>
    <div class="row">
      <div class="pill">Grid <input id="gridToggle" class="grid-toggle" type="checkbox" checked></div>
      <div class="pill">FOV <input id="fov" type="range" min="50" max="95" value="74"></div>
    </div>

    <h3>‚ôªÔ∏è Prestige</h3>
    <div class="row"><div class="pill">Rebirth (reset for √ó1.5 mult)</div><button class="btn danger" id="rebirthBtn">Rebirth</button></div>
  </div>

  <canvas class="minimap" id="minimap"></canvas>
  <div class="hint">Click to lock mouse ‚Ä¢ WASD move ‚Ä¢ Space jump ‚Ä¢ Shift sprint ‚Ä¢ R rotate placement ‚Ä¢ Q/E raise/lower in placement ‚Ä¢ Esc to unlock</div>
  <div class="toast" id="toast" hidden></div>
</div>

<!-- Three.js -->
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>
/* ===============================
   Roblox-Style Tycoon (Single File)
   Systems:
   - World + Player (PointerLock)
   - Conveyors, Droppers (3 tiers), Items
   - Collector station + particles + sound
   - Shop with placement mode
   - Save/Load (localStorage)
   - Day/Night cycle
   - Minimap & Settings
   - Worker NPC, Prestige
================================= */

// ---------- Utility ----------
const clamp=(n,a,b)=>Math.min(b,Math.max(a,n));
const lerp=(a,b,t)=>a+(b-a)*t;
const rand=(a,b)=>a+Math.random()*(b-a);
const TAU=Math.PI*2;

function fmt(n){ // money formatting
  if(n>=1e12) return (n/1e12).toFixed(2)+'T';
  if(n>=1e9) return (n/1e9).toFixed(2)+'B';
  if(n>=1e6) return (n/1e6).toFixed(2)+'M';
  if(n>=1e3) return (n/1e3).toFixed(2)+'K';
  return Math.floor(n).toString();
}

function toast(msg, ms=1800){
  const el=document.getElementById('toast');
  el.textContent=msg; el.hidden=false;
  clearTimeout(toast._t);
  toast._t=setTimeout(()=>el.hidden=true, ms);
}

// ---------- State ----------
let state={
  money: 150,
  mult: 1.0,
  speed: 1.0,         // conveyor speed multiplier
  worker: false,
  grid:true,
  fov:74,
  // dynamic arrays:
  conveyors:[], // {pos:[x,y,z], rotY:number}
  droppers:[],  // {pos:[x,y,z], rotY:number, tier:1|2|3}
};

const COSTS={
  dropper1:  50,
  dropper2:  400,
  dropper3:  2000,
  conveyor:  75,
  speed:     300,
  worker:    1200,
};

const SCALING={
  dropper: 1.22,
  conveyor:1.18,
  speed:   1.35,
  worker:  1.6,
};

const TIERS={
  1:{rate:1.25, value:10, color:0x22c55e},
  2:{rate:1.6,  value:35, color:0xf59e0b},
  3:{rate:2.2,  value:120,color:0x38bdf8},
};

// ---------- Three.js Setup ----------
const scene=new THREE.Scene();
scene.background=new THREE.Color(0x87c0ff); // day sky (changes)
const camera=new THREE.PerspectiveCamera(state.fov, innerWidth/innerHeight, 0.1, 500);
const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
renderer.shadowMap.enabled=true;
document.body.appendChild(renderer.domElement);

// Lights
const dirLight=new THREE.DirectionalLight(0xffffff,1.0);
dirLight.position.set(30,60,30);
dirLight.castShadow=true;
dirLight.shadow.mapSize.set(2048,2048);
scene.add(dirLight);
scene.add(new THREE.AmbientLight(0xffffff,0.35));

// Ground & Grid
const groundGeo=new THREE.PlaneGeometry(200,200);
const groundMat=new THREE.MeshStandardMaterial({color:0x2a3b20});
const ground=new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x=-Math.PI/2; ground.receiveShadow=true;
scene.add(ground);

const gridHelper=new THREE.GridHelper(200, 200, 0x2f415f, 0x1a2536);
gridHelper.position.y=0.01;
scene.add(gridHelper);

// Player (capsule)
const player={
  obj:new THREE.Object3D(),
  vel:new THREE.Vector3(),
  onGround:false,
};
scene.add(player.obj);
const playerBody=new THREE.Mesh(
  new THREE.CapsuleGeometry(0.4, 1.0, 8, 16),
  new THREE.MeshStandardMaterial({color:0xffeb7a})
);
playerBody.castShadow=true;
player.obj.add(playerBody);

// Camera boom
const camPivot=new THREE.Object3D();
camPivot.position.set(0,1.1,0);
player.obj.add(camPivot);
const camBoom=new THREE.Object3D();
camBoom.position.set(0,0,0);
camPivot.add(camBoom);
camera.position.set(0,1.2,3.5);
camBoom.add(camera);

// Collector station
const collector=new THREE.Mesh(
  new THREE.BoxGeometry(2,1,2),
  new THREE.MeshStandardMaterial({color:0x7074ff, metalness:.1, roughness:.6})
);
collector.position.set(6,0.5,0);
collector.castShadow=true; collector.receiveShadow=true;
scene.add(collector);

const collectorGlow=new THREE.Mesh(
  new THREE.BoxGeometry(1.2,0.6,1.2),
  new THREE.MeshBasicMaterial({color:0xffff00})
);
collectorGlow.position.set(0,0.5,0);
collector.add(collectorGlow);

// Base pad
const base=new THREE.Mesh(
  new THREE.BoxGeometry(14,0.3,10),
  new THREE.MeshStandardMaterial({color:0x3b3b3b})
);
base.position.set(0,0.15,0);
base.receiveShadow=true;
scene.add(base);

// Initial conveyor and dropper for orientation
// (Players will add more via placement)
addConveyor({x:-3.5,y:0.2,z:0, rotY:0}); // short intro segment

// ---------- Physics & Colliders (simple) ----------
const colliders=[ground, base, collector]; // ground is infinite plane for y

// ---------- Input / Pointer Lock ----------
const keys={};
document.addEventListener('keydown',e=>keys[e.code]=true);
document.addEventListener('keyup',e=>keys[e.code]=false);

renderer.domElement.addEventListener('click',()=>renderer.domElement.requestPointerLock());
document.addEventListener('pointerlockchange',()=>{
  if(document.pointerLockElement===renderer.domElement){ document.addEventListener('mousemove', onMouseMove); }
  else { document.removeEventListener('mousemove', onMouseMove); }
});

let yaw=0,pitch=0;
function onMouseMove(e){
  const sens=0.0022;
  yaw-=e.movementX*sens;
  pitch-=e.movementY*sens;
  pitch=clamp(pitch,-1.1,1.1);
  camPivot.rotation.y=yaw;
  camPivot.rotation.x=pitch;
}

// ---------- Conveyor / Dropper / Item Systems ----------
const conveyors=[]; // {mesh, dir:THREE.Vector3}
const droppers=[];  // {mesh, tier, cooldown}

const items=[];     // {mesh, vel:Vector3}

function addConveyor({x,y,z, rotY}){
  const geo=new THREE.BoxGeometry(3,0.2,1.6);
  const mat=new THREE.MeshStandardMaterial({color:0x3333ff, metalness:.2, roughness:.7});
  const m=new THREE.Mesh(geo, mat);
  m.position.set(x,y,z);
  m.rotation.y=rotY||0;
  m.castShadow=true; m.receiveShadow=true;
  scene.add(m);

  const dir=new THREE.Vector3(1,0,0).applyAxisAngle(new THREE.Vector3(0,1,0), m.rotation.y);
  conveyors.push({mesh:m, dir});
  state.conveyors.push({pos:[x,y,z], rotY:m.rotation.y});
  return m;
}

function addDropper({x,y,z, rotY=0, tier=1}){
  const t=TIERS[tier];
  const body=new THREE.Mesh(
    new THREE.BoxGeometry(0.8,1.2,0.8),
    new THREE.MeshStandardMaterial({color:t.color, metalness:.2, roughness:.7})
  );
  body.position.set(x,y+0.6,z);
  body.rotation.y=rotY;
  body.castShadow=true; body.receiveShadow=true;

  const spout=new THREE.Mesh(
    new THREE.BoxGeometry(0.4,0.4,0.6),
    new THREE.MeshStandardMaterial({color:0x222})
  );
  spout.position.set(0,-0.2,0.6);
  body.add(spout);

  scene.add(body);
  const d={mesh:body, tier, cooldown:rand(0.2,0.9)};
  droppers.push(d);
  state.droppers.push({pos:[x,y,z], rotY, tier});
  return body;
}

function spawnItem(pos, tier){
  const t=TIERS[tier];
  const geo=new THREE.BoxGeometry(0.35,0.35,0.35);
  const mat=new THREE.MeshStandardMaterial({color:t.color});
  const cube=new THREE.Mesh(geo, mat);
  cube.position.copy(pos);
  cube.castShadow=true; cube.receiveShadow=true;
  scene.add(cube);
  items.push({mesh:cube, vel:new THREE.Vector3(0,0,0), tier});
}

function moveItems(dt){
  const speed=1.2*state.speed;
  // For each item, find closest conveyor it's above and project motion along it
  for(let i=items.length-1;i>=0;i--){
    const it=items[i]; const m=it.mesh;
    // gravity
    it.vel.y-=9*dt;
    m.position.addScaledVector(it.vel, dt);

    // Simple ground clamp
    if(m.position.y<0.3){ m.position.y=0.3; it.vel.y=0; }

    // Check conveyor surfaces proximity
    let applied=false;
    for(const c of conveyors){
      const surfY=c.mesh.position.y+0.2; // top surface
      const local=m.position.clone().sub(c.mesh.position).applyAxisAngle(new THREE.Vector3(0,1,0), -c.mesh.rotation.y);
      if(Math.abs(local.y-(surfY-c.mesh.position.y))<0.25 && Math.abs(local.x)<=1.6 && Math.abs(local.z)<=0.9){
        // On top of conveyor: stick and move along its dir
        m.position.y=surfY+0.05;
        it.vel.set(0,0,0);
        m.position.addScaledVector(c.dir, speed*dt);
        applied=true;
        break;
      }
    }

    // Collector check (simple box distance)
    if(m.position.distanceTo(collector.position)<1.1){
      const value=TIERS[it.tier].value*state.mult;
      earn(value);
      burst(collector.position, 8);
      scene.remove(m); items.splice(i,1);
      continue;
    }

    // Cleanup if it flies away
    if(Math.abs(m.position.x)>300||Math.abs(m.position.z)>300){ scene.remove(m); items.splice(i,1); }
  }
}

function updateDroppers(dt){
  for(const d of droppers){
    d.cooldown-=dt*TIERS[d.tier].rate;
    if(d.cooldown<=0){
      d.cooldown=1;
      const worldPos=new THREE.Vector3(0,-0.3,1.0).applyMatrix4(d.mesh.matrixWorld);
      spawnItem(worldPos, d.tier);
    }
  }
}

// ---------- Particles ----------
const particles=[];
function burst(center, count=10){
  for(let i=0;i<count;i++){
    const p=new THREE.Mesh(
      new THREE.SphereGeometry(0.06,8,8),
      new THREE.MeshStandardMaterial({color:0xffff88, emissive:0x443300})
    );
    p.position.copy(center);
    p.userData.vel=new THREE.Vector3(rand(-1,1), rand(1.2,2.2), rand(-1,1));
    p.userData.life=0.8;
    scene.add(p);
    particles.push(p);
  }
}
function updateParticles(dt){
  for(let i=particles.length-1;i>=0;i--){
    const p=particles[i];
    p.userData.life-=dt;
    p.position.addScaledVector(p.userData.vel, dt);
    p.userData.vel.y-=4*dt;
    if(p.userData.life<=0){ scene.remove(p); particles.splice(i,1); }
  }
}

// ---------- Economy ----------
function earn(v){
  state.money+=v;
  updateUI();
}
function canAfford(c){ return state.money>=c; }
function spend(c){
  if(!canAfford(c)) return false;
  state.money-=c; updateUI(); return true;
}

function price(key, base){
  // scale by owned count
  let n=0;
  if(key.startsWith('dropper')) n=state.droppers.filter(d=>`dropper${d.tier}`===key).length;
  if(key==='conveyor') n=state.conveyors.length;
  if(key==='speed') n=Math.floor((state.speed-1)*10); // each +0.1 counts
  if(key==='worker') n=state.worker?1:0;
  const factor = SCALING[key] ?? 1.2;
  return Math.floor(base*Math.pow(factor, n));
}

// ---------- Build / Placement ----------
let buildMode=null; // {type:'conveyor'|'dropper', tier?, rotY, heightOffset}
let ghost=null;

function setBuildMode(m){ // m = null or {type,tier?}
  buildMode=m;
  if(ghost){ scene.remove(ghost); ghost=null; }
  if(!m) return;
  if(m.type==='conveyor'){
    ghost=new THREE.Mesh(new THREE.BoxGeometry(3,0.2,1.6), new THREE.MeshStandardMaterial({color:0x99aaff,transparent:true,opacity:.4}));
  } else if(m.type==='dropper'){
    const color=TIERS[m.tier].color;
    ghost=new THREE.Mesh(new THREE.BoxGeometry(0.8,1.2,0.8), new THREE.MeshStandardMaterial({color,transparent:true,opacity:.4}));
  }
  ghost.castShadow=false; ghost.receiveShadow=false;
  scene.add(ghost);
  buildMode.rotY=0;
  buildMode.heightOffset=0;
}

const raycaster=new THREE.Raycaster();
const mouse=new THREE.Vector2();
window.addEventListener('mousemove',(e)=>{
  if(!buildMode||!ghost) return;
  mouse.x=(e.clientX/innerWidth)*2-1;
  mouse.y=-(e.clientY/innerHeight)*2+1;
  raycaster.setFromCamera(mouse, camera);
  const inter=raycaster.intersectObjects([ground, base], true)[0];
  if(inter){
    ghost.position.copy(inter.point);
    ghost.position.y=0.2+buildMode.heightOffset;
    ghost.rotation.y=buildMode.rotY;
  }
});
window.addEventListener('mousedown',(e)=>{
  // Place if in build mode
  if(buildMode && e.button===0){
    if(buildMode.type==='conveyor'){
      const cost=price('conveyor', COSTS.conveyor);
      if(spend(cost)){
        addConveyor({x:ghost.position.x, y:ghost.position.y, z:ghost.position.z, rotY:ghost.rotation.y});
        toast(`Placed conveyor ($${fmt(cost)})`);
      } else toast('Not enough money!');
    } else if(buildMode.type==='dropper'){
      const key=`dropper${buildMode.tier}`;
      const base=COSTS[`dropper${buildMode.tier}`];
      const cost=price(key, base);
      if(spend(cost)){
        addDropper({x:ghost.position.x, y:0.0, z:ghost.position.z, rotY:ghost.rotation.y, tier:buildMode.tier});
        toast(`Placed Tier ${buildMode.tier} dropper ($${fmt(cost)})`);
      } else toast('Not enough money!');
    }
  }
});

window.addEventListener('keydown',(e)=>{
  if(!buildMode) return;
  if(e.code==='KeyR'){ buildMode.rotY+=Math.PI/2; if(ghost) ghost.rotation.y=buildMode.rotY; }
  if(e.code==='KeyQ'){ buildMode.heightOffset=clamp(buildMode.heightOffset-0.1,-0.0,1.5); }
  if(e.code==='KeyE'){ buildMode.heightOffset=clamp(buildMode.heightOffset+0.1,-0.0,1.5); }
});

// ---------- Worker NPC ----------
let worker=null;
function ensureWorker(){
  if(worker || !state.worker) return;
  const w=new THREE.Mesh(new THREE.CapsuleGeometry(0.3,0.7,6,12), new THREE.MeshStandardMaterial({color:0x9ad0ff}));
  w.position.set(2,0.6,2);
  w.castShadow=true;
  scene.add(w);
  worker={mesh:w, cooldown:0};
}
function updateWorker(dt){
  if(!worker) return;
  worker.cooldown-=dt;
  if(worker.cooldown<=0){
    worker.cooldown=2.5;
    // Nudge nearest item upwards if it's slightly sunk
    let best=null, bestD=999;
    for(const it of items){
      const d=it.mesh.position.distanceTo(worker.mesh.position);
      if(d<bestD){ best=it; bestD=d; }
    }
    if(best && bestD<6){
      best.mesh.position.y+=0.4;
      best.vel.set(0,0,0);
      toast('Worker rescued an item');
    }
  }
}

// ---------- Day/Night ----------
let tDay=0; // 0..1
function updateDayNight(dt){
  tDay=(tDay+dt*0.02)%1;
  const theta=tDay*TAU;
  const sunY=Math.cos(theta)*0.8+0.2;
  dirLight.intensity=clamp(sunY,0.1,1.0);
  dirLight.position.set(30*Math.cos(theta), 40*clamp(sunY,0.1,1.0)+10, 30*Math.sin(theta));
  const skyCol=new THREE.Color().setHSL(0.58, 0.45, lerp(0.45, 0.08, (1-sunY)));
  scene.background=skyCol;
}

// ---------- Player Movement ----------
function updatePlayer(dt){
  const speed=(keys.ShiftLeft?6.3:4.0);
  const fwd=new THREE.Vector3(0,0,-1).applyEuler(camPivot.rotation);
  fwd.y=0; fwd.normalize();
  const right=new THREE.Vector3().crossVectors(fwd,new THREE.Vector3(0,1,0)).normalize().multiplyScalar(-1);

  let acc=new THREE.Vector3();
  if(keys.KeyW) acc.add(fwd);
  if(keys.KeyS) acc.sub(fwd);
  if(keys.KeyA) acc.sub(right);
  if(keys.KeyD) acc.add(right);

  if(acc.lengthSq()>0) acc.normalize().multiplyScalar(speed);
  player.vel.x=lerp(player.vel.x, acc.x, 0.18);
  player.vel.z=lerp(player.vel.z, acc.z, 0.18);

  // gravity & jump
  player.vel.y-=18*dt;
  if(player.obj.position.y<=0.8){ player.obj.position.y=0.8; player.vel.y=0; player.onGround=true; }
  else player.onGround=false;
  if(keys.Space && player.onGround){ player.vel.y=6.3; }

  player.obj.position.addScaledVector(player.vel, dt);
}

// ---------- UI ----------
const moneyEl=document.getElementById('money');
const multEl=document.getElementById('mult');
const fovSlider=document.getElementById('fov');
const gridToggle=document.getElementById('gridToggle');

function updateUI(){
  moneyEl.textContent=fmt(state.money);
  multEl.textContent=state.mult.toFixed(1)+'x';
  // Buttons cost text
  setCostBtn('buyDropper1', 'Buy Tier 1', price('dropper1', COSTS.dropper1));
  setCostBtn('buyDropper2', 'Buy Tier 2', price('dropper2', COSTS.dropper2));
  setCostBtn('buyDropper3', 'Buy Tier 3', price('dropper3', COSTS.dropper3));
  setCostBtn('buyConveyor', 'Buy Conveyor', price('conveyor', COSTS.conveyor));
  setCostBtn('buySpeed', 'Upgrade Speed', price('speed', COSTS.speed));
  setCostBtn('buyWorker', state.worker?'Worker Hired':'Hire Worker', state.worker?0:price('worker', COSTS.worker), !!state.worker);
}

function setCostBtn(id,label,cost,disabled=false){
  const el=document.getElementById(id);
  el.textContent = cost>0 ? `${label} ($${fmt(cost)})` : label;
  el.disabled = disabled || !canAfford(cost);
}

document.getElementById('buyConveyor').onclick=()=>{
  setBuildMode({type:'conveyor'});
};
document.getElementById('buyDropper1').onclick=()=>{
  setBuildMode({type:'dropper', tier:1});
};
document.getElementById('buyDropper2').onclick=()=>{
  setBuildMode({type:'dropper', tier:2});
};
document.getElementById('buyDropper3').onclick=()=>{
  setBuildMode({type:'dropper', tier:3});
};
document.getElementById('buySpeed').onclick=()=>{
  const cost=price('speed', COSTS.speed);
  if(spend(cost)){ state.speed=+(state.speed+0.1).toFixed(2); toast(`Conveyor speed +10% ($${fmt(cost)})`); updateUI(); }
};
document.getElementById('buyWorker').onclick=()=>{
  if(state.worker){ toast('Worker already hired'); return; }
  const cost=price('worker', COSTS.worker);
  if(spend(cost)){ state.worker=true; ensureWorker(); toast('Worker hired!'); updateUI(); }
};

document.getElementById('rebirthBtn').onclick=()=>{
  if(state.money<50000){ toast('Need $50,000 to rebirth'); return; }
  state={money:150, mult:+(state.mult*1.5).toFixed(1), speed:1.0, worker:false, grid:state.grid, fov:state.fov, conveyors:[], droppers:[]};
  // cleanup scene objects
  for(const c of conveyors) scene.remove(c.mesh);
  for(const d of droppers) scene.remove(d.mesh);
  for(const it of items) scene.remove(it.mesh);
  conveyors.length=0; droppers.length=0; items.length=0;
  addConveyor({x:-3.5,y:0.2,z:0, rotY:0});
  updateUI(); toast('Rebirth complete! Multiplier increased.');
};

document.getElementById('saveBtn').onclick=()=>{
  localStorage.setItem('tycoon-save', JSON.stringify(state));
  toast('Game saved!');
};
document.getElementById('loadBtn').onclick=loadState;

fovSlider.addEventListener('input',()=>{
  state.fov=+fovSlider.value; camera.fov=state.fov; camera.updateProjectionMatrix();
});
gridToggle.addEventListener('change',()=>{
  state.grid=gridToggle.checked; gridHelper.visible=state.grid;
});

// ---------- Minimap ----------
const minimap=document.getElementById('minimap');
const mmCtx=minimap.getContext('2d');
function drawMinimap(){
  const w=minimap.width=minimap.clientWidth*devicePixelRatio;
  const h=minimap.height=minimap.clientHeight*devicePixelRatio;
  mmCtx.clearRect(0,0,w,h);
  mmCtx.fillStyle='#0b132a'; mmCtx.fillRect(0,0,w,h);
  // base
  mmCtx.fillStyle='#2b8443';
  mmCtx.fillRect(w*0.1,h*0.1,w*0.8,h*0.8);
  // conveyors
  mmCtx.fillStyle='#6a6cff';
  for(const c of conveyors){
    const x=(c.mesh.position.x/200+0.5)*w;
    const y=(c.mesh.position.z/200+0.5)*h;
    mmCtx.fillRect(x-3,y-3,6,6);
  }
  // droppers
  mmCtx.fillStyle='#ffd54a';
  for(const d of droppers){
    const x=(d.mesh.position.x/200+0.5)*w;
    const y=(d.mesh.position.z/200+0.5)*h;
    mmCtx.fillRect(x-3,y-3,6,6);
  }
  // player
  mmCtx.fillStyle='#ffffff';
  const px=(player.obj.position.x/200+0.5)*w;
  const py=(player.obj.position.z/200+0.5)*h;
  mmCtx.beginPath(); mmCtx.arc(px,py,4,0,TAU); mmCtx.fill();
}

// ---------- Save / Load ----------
function loadState(){
  const raw=localStorage.getItem('tycoon-save');
  if(!raw){ toast('No save found'); return; }
  try{
    const s=JSON.parse(raw);
    // replace state
    state=s;
    // Cleanup existing
    for(const c of conveyors) scene.remove(c.mesh);
    for(const d of droppers) scene.remove(d.mesh);
    for(const it of items) scene.remove(it.mesh);
    conveyors.length=0; droppers.length=0; items.length=0;

    // Rebuild from state arrays
    for(const c of state.conveyors){ addConveyor({x:c.pos[0],y:c.pos[1],z:c.pos[2], rotY:c.rotY}); }
    for(const d of state.droppers){ addDropper({x:d.pos[0],y:d.pos[1],z:d.pos[2], rotY:d.rotY, tier:d.tier}); }
    // worker
    if(state.worker) ensureWorker();
    // UI settings
    gridHelper.visible=state.grid; gridToggle.checked=state.grid;
    camera.fov=state.fov; camera.updateProjectionMatrix(); fovSlider.value=state.fov;
    updateUI();
    toast('Loaded save!');
  }catch(e){ console.error(e); toast('Failed to load save'); }
}

// ---------- Game Loop ----------
let last=performance.now();
function loop(now){
  const dt=Math.min(0.033,(now-last)/1000); last=now;

  updatePlayer(dt);
  updateDroppers(dt);
  moveItems(dt);
  updateParticles(dt);
  updateWorker(dt);
  updateDayNight(dt);
  drawMinimap();

  renderer.render(scene, camera);
  requestAnimationFrame(loop);
}
updateUI();
ensureWorker(); // only spawns if hired later; safe call
requestAnimationFrame(loop);

// ---------- Starter content ----------
addDropper({x:-5.5,y:0.0,z:0,rotY:0,tier:1}); // a starter dropper for feel

// ---------- Quality-of-life ----------
window.addEventListener('resize',()=>{
  camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
