<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Roblox-Style Tycoon ‚Äì Single File</title>
<style>
  :root{
    --ui:#0b132a; --panel:#0f172a; --muted:#94a3b8; --text:#e5e7eb; --accent:#22c55e; --buy:#fbbf24;
  }
  html,body{height:100%}
  body{margin:0;background:#0b1025;color:var(--text);font-family:Inter,system-ui,Segoe UI,Roboto,Arial;overflow:hidden}
  #hud{position:fixed;inset:0;pointer-events:none}
  .top{position:absolute;left:10px;top:10px;display:flex;gap:10px;pointer-events:auto}
  .badge{background:rgba(12,18,38,.8);border:1px solid #1f2b52;padding:8px 12px;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.35);font-variant-numeric:tabular-nums}
  .money{font-weight:800}
  .help{position:absolute;left:50%;bottom:10px;transform:translateX(-50%);background:rgba(12,18,38,.85);border:1px solid #1f2b52;padding:8px 12px;border-radius:12px;pointer-events:auto;font-size:13px}
  .btn{background:#0b132a;border:1px solid #1f2b52;padding:6px 10px;border-radius:8px;color:#cfe8ff;cursor:pointer}
  .btn:disabled{opacity:.5;cursor:not-allowed}
  .toast{position:absolute;right:10px;bottom:10px;background:#0b132a;border:1px solid #1f2b52;padding:8px 10px;border-radius:10px;pointer-events:auto;max-width:320px}
  canvas{display:block;outline:none}
</style>
</head>
<body>
<div id="hud">
  <div class="top">
    <div class="badge money">üí∞ <span id="money">0</span></div>
    <div class="badge">üéõÔ∏è <span id="status">WASD move ‚Ä¢ Mouse drag look ‚Ä¢ E interact</span></div>
    <button id="saveBtn" class="btn">Save</button>
    <button id="loadBtn" class="btn">Load</button>
    <button id="resetBtn" class="btn">Reset</button>
  </div>
  <div class="help">Step on <b>glowing yellow circles</b> to buy (press <b>E</b>). Items ride conveyors into the collector to earn cash.</div>
  <div id="toast" class="toast" hidden></div>
</div>

<!-- Three.js -->
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/libs/stats.min.js"></script>

<script>
/* ==========================================================
   Roblox-Style Tycoon ‚Äì Full Single-File Demo (HTML+CSS+JS)
   Systems:
   - Scene, lighting, sky
   - Player (WASD) + mouse-drag camera (3rd person follow)
   - Conveyors, droppers (tiers), items with values
   - Collector with earnings + particles
   - Buy pads you step on & press E to purchase machines & floors
   - Save/Load to localStorage
========================================================== */

// ---------- Utility ----------
const clamp=(n,a,b)=>Math.min(b,Math.max(a,n));
const lerp=(a,b,t)=>a+(b-a)*t;
const rand=(a,b)=>a+Math.random()*(b-a);
function fmt(n){ if(n>=1e9) return (n/1e9).toFixed(2)+'B'; if(n>=1e6) return (n/1e6).toFixed(2)+'M'; if(n>=1e3) return (n/1e3).toFixed(1)+'K'; return Math.floor(n).toString(); }
function toast(msg, ms=1600){ const el=document.getElementById('toast'); el.textContent=msg; el.hidden=false; clearTimeout(toast._t); toast._t=setTimeout(()=>el.hidden=true,ms); }

// ---------- State ----------
let state = {
  money: 150,
  floorsUnlocked: 1,
  conveyors: [],    // saved: {pos:[x,y,z], rotY}
  droppers: [],     // saved: {pos:[x,y,z], rotY, tier}
  hasCollector: false
};

const TIER = {
  1: { rate: 1.1, value: 10, color: 0x22c55e },
  2: { rate: 1.6, value: 35, color: 0xf59e0b },
  3: { rate: 2.2, value: 120, color: 0x38bdf8 }
};

const COST = {
  conveyor: 75,
  collector: 200,
  dropper1: 60,
  dropper2: 300,
  dropper3: 1200,
  floor2: 500,
  floor3: 2500
};

// ---------- Three Setup ----------
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x86c6ff); // sky

const camera = new THREE.PerspectiveCamera(74, innerWidth/innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

// Lights
const sun = new THREE.DirectionalLight(0xffffff, 1.0);
sun.position.set(30, 50, 20);
sun.castShadow = true;
sun.shadow.mapSize.set(2048,2048);
scene.add(sun);
scene.add(new THREE.AmbientLight(0xffffff, 0.35));

// Ground
const ground = new THREE.Mesh(
  new THREE.PlaneGeometry(140,140),
  new THREE.MeshStandardMaterial({color:0x2f7d32})
);
ground.rotation.x = -Math.PI/2;
ground.receiveShadow = true;
scene.add(ground);

// Baseplate
const base = new THREE.Mesh(
  new THREE.BoxGeometry(24,0.4,20),
  new THREE.MeshStandardMaterial({color:0x3a3a3a})
);
base.position.set(0,0.2,0);
base.receiveShadow=true; base.castShadow=true;
scene.add(base);

// Floors (second & third spawn later)
const floors = [base];
function addUpperFloor(level){ // level 2 => y=5, level 3 => y=10
  const y = (level-1)*5 + 0.2;
  const f = new THREE.Mesh(new THREE.BoxGeometry(24,0.4,20), new THREE.MeshStandardMaterial({color:0x515151}));
  f.position.set(0,y,0);
  f.receiveShadow=true; f.castShadow=true;
  scene.add(f); floors[level-1]=f;
  // stairs up to that level
  const stairs = new THREE.Mesh(new THREE.BoxGeometry(2,5,4), new THREE.MeshStandardMaterial({color:0x666}));
  stairs.position.set(-10, y/2, 7.5);
  scene.add(stairs);
}

// ---------- Player ----------
const player = new THREE.Mesh(
  new THREE.BoxGeometry(1,2,1),
  new THREE.MeshStandardMaterial({color:0x2ea8ff})
);
player.position.set(0,1,6);
player.castShadow=true; player.receiveShadow=true;
scene.add(player);

let yaw = 0, pitch = 0;
let dragging = false;
window.addEventListener('mousedown',()=>dragging=true);
window.addEventListener('mouseup',()=>dragging=false);
window.addEventListener('mousemove',e=>{
  if(!dragging) return;
  yaw -= e.movementX*0.003;
  pitch = clamp(pitch - e.movementY*0.003, -0.9, 0.9);
});

const keys={};
window.addEventListener('keydown',e=>keys[e.key.toLowerCase()]=true);
window.addEventListener('keyup',e=>keys[e.key.toLowerCase()]=false);

function updatePlayer(dt){
  const forward = new THREE.Vector3(Math.sin(yaw),0,-Math.cos(yaw));
  const right = new THREE.Vector3(-forward.z,0,forward.x);
  let dir = new THREE.Vector3();
  if(keys['w']) dir.add(forward);
  if(keys['s']) dir.sub(forward);
  if(keys['a']) dir.sub(right);
  if(keys['d']) dir.add(right);
  if(dir.lengthSq()>0) dir.normalize();
  const speed = keys['shift']? 9 : 5.5;
  player.position.addScaledVector(dir, speed*dt);
  // clamp inside play area
  player.position.x = clamp(player.position.x, -65, 65);
  player.position.z = clamp(player.position.z, -65, 65);

  // camera follow boom
  const camDist = 9, camHeight=4;
  const camTarget = player.position.clone();
  const camPos = player.position.clone()
    .addScaledVector(forward, -camDist)
    .add(new THREE.Vector3(0,camHeight,0));
  camera.position.lerp(camPos, 1 - Math.pow(0.001, dt*60));
  camera.lookAt(camTarget);
}

// ---------- Machines ----------
const conveyors = []; // {mesh, dir:Vector3}
const droppers = [];  // {mesh, tier, cooldown}
const items = [];     // {mesh, vel:Vector3, tier}
let collector = null;

function addConveyor(pos, rotY){
  const m = new THREE.Mesh(
    new THREE.BoxGeometry(4,0.25,1.8),
    new THREE.MeshStandardMaterial({color:0x3b3bff, metalness:.15, roughness:.7})
  );
  m.position.copy(pos);
  m.rotation.y = rotY||0;
  m.castShadow=true; m.receiveShadow=true;
  scene.add(m);
  const dir = new THREE.Vector3(1,0,0).applyAxisAngle(new THREE.Vector3(0,1,0), m.rotation.y);
  conveyors.push({mesh:m, dir});
  state.conveyors.push({pos:[pos.x,pos.y,pos.z], rotY:m.rotation.y});
  return m;
}

function addDropper(pos, rotY, tier){
  const t = TIER[tier];
  const body = new THREE.Mesh(
    new THREE.BoxGeometry(0.9,1.4,0.9),
    new THREE.MeshStandardMaterial({color:t.color, metalness:.2, roughness:.7})
  );
  body.position.copy(pos).add(new THREE.Vector3(0,0.7,0));
  body.rotation.y = rotY||0;
  body.castShadow=true; body.receiveShadow=true;

  const spout = new THREE.Mesh(new THREE.BoxGeometry(0.4,0.3,0.6), new THREE.MeshStandardMaterial({color:0x222}));
  spout.position.set(0,-0.3,0.6);
  body.add(spout);

  scene.add(body);
  droppers.push({mesh:body, tier, cooldown:rand(0.3,0.9)});
  state.droppers.push({pos:[pos.x,pos.y,pos.z], rotY:body.rotation.y, tier});
  return body;
}

function addCollector(pos){
  const c = new THREE.Mesh(
    new THREE.BoxGeometry(2.2,0.9,2.2),
    new THREE.MeshStandardMaterial({color:0x7074ff})
  );
  c.position.copy(pos).add(new THREE.Vector3(0,0.45,0));
  c.castShadow=true; c.receiveShadow=true;
  scene.add(c);
  const glow = new THREE.Mesh(new THREE.BoxGeometry(1.2,0.5,1.2), new THREE.MeshBasicMaterial({color:0xffff66}));
  glow.position.set(0,0.25,0);
  c.add(glow);
  collector = c;
  state.hasCollector = true;
  return c;
}

function spawnItem(worldPos, tier){
  const t = TIER[tier];
  const cube = new THREE.Mesh(
    new THREE.BoxGeometry(0.35,0.35,0.35),
    new THREE.MeshStandardMaterial({color:t.color})
  );
  cube.position.copy(worldPos);
  cube.castShadow=true; cube.receiveShadow=true;
  scene.add(cube);
  items.push({mesh:cube, vel:new THREE.Vector3(0,0,0), tier});
}

function updateDroppers(dt){
  for(const d of droppers){
    d.cooldown -= dt * TIER[d.tier].rate;
    if(d.cooldown<=0){
      d.cooldown = 1;
      const wp = new THREE.Vector3(0,-0.25,0.9).applyMatrix4(d.mesh.matrixWorld);
      spawnItem(wp, d.tier);
    }
  }
}

function updateItems(dt){
  const speed = 1.25;
  for(let i=items.length-1;i>=0;i--){
    const it = items[i], m = it.mesh;

    // gravity + floor clamp (simple)
    it.vel.y -= 9*dt;
    m.position.addScaledVector(it.vel, dt);
    if(m.position.y<0.25){ m.position.y=0.25; it.vel.y=0; }

    // ride conveyors
    for(const c of conveyors){
      const topY = c.mesh.position.y+0.125;
      const lp = m.position.clone().sub(c.mesh.position).applyAxisAngle(new THREE.Vector3(0,1,0), -c.mesh.rotation.y);
      if(Math.abs(lp.y-(topY-c.mesh.position.y))<0.22 && Math.abs(lp.x)<=2.1 && Math.abs(lp.z)<=0.95){
        // on top
        m.position.y = topY + 0.05;
        it.vel.set(0,0,0);
        m.position.addScaledVector(c.dir, speed*dt);
        break;
      }
    }

    // collector
    if(collector && m.position.distanceTo(collector.position)<1.2){
      const val = TIER[it.tier].value;
      earn(val);
      burst(collector.position, 8);
      scene.remove(m); items.splice(i,1); continue;
    }

    if(Math.abs(m.position.x)>300||Math.abs(m.position.z)>300){ scene.remove(m); items.splice(i,1); }
  }
}

// particles
const particles=[];
function burst(center,count=10){
  for(let i=0;i<count;i++){
    const p = new THREE.Mesh(new THREE.SphereGeometry(0.06,8,8),
      new THREE.MeshStandardMaterial({color:0xffff88, emissive:0x442200}));
    p.position.copy(center);
    p.userData.vel = new THREE.Vector3(rand(-1,1),rand(1.2,2.2),rand(-1,1));
    p.userData.life = 0.7;
    scene.add(p); particles.push(p);
  }
}
function updateParticles(dt){
  for(let i=particles.length-1;i>=0;i--){
    const p=particles[i];
    p.userData.life-=dt;
    p.position.addScaledVector(p.userData.vel, dt);
    p.userData.vel.y-=4*dt;
    if(p.userData.life<=0){ scene.remove(p); particles.splice(i,1); }
  }
}

// ---------- Economy/UI ----------
const moneyEl = document.getElementById('money');
function earn(v){ state.money+=v; moneyEl.textContent = fmt(state.money); }
function canAfford(c){ return state.money>=c; }
function spend(c){ if(!canAfford(c)) return false; state.money-=c; moneyEl.textContent = fmt(state.money); return true; }

// ---------- Buy Pads ----------
const buyPads=[]; // {mesh, label, cost, onBuy, purchased:false}
const labelCanvas = (text)=>{ // simple dynamic label sprite
  const c=document.createElement('canvas'); c.width=256; c.height=128;
  const ctx=c.getContext('2d');
  ctx.fillStyle='rgba(0,0,0,0.5)'; ctx.fillRect(0,0,c.width,c.height);
  ctx.fillStyle='#fff'; ctx.font='24px Inter, Arial'; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText(text, c.width/2, c.height/2);
  const tex = new THREE.CanvasTexture(c); tex.needsUpdate=true; return tex;
};

function addBuyPad(pos, cost, text, onBuy){
  const pad = new THREE.Mesh(
    new THREE.CylinderGeometry(1.1,1.1,0.2,32),
    new THREE.MeshStandardMaterial({color:0xfbbf24, transparent:true, opacity:0.8})
  );
  pad.position.copy(pos);
  pad.rotation.x=0;
  pad.castShadow=true; pad.receiveShadow=true;
  scene.add(pad);

  const sign = new THREE.Sprite(new THREE.SpriteMaterial({map:labelCanvas(`${text}\n$${fmt(cost)}`)}));
  sign.scale.set(2.6,1.3,1);
  sign.position.set(0,1.6,0);
  pad.add(sign);

  buyPads.push({mesh:pad, cost, onBuy, label:text, purchased:false, sign});
  return pad;
}

function updateBuyPads(dt){
  for(const b of buyPads){
    if(b.purchased) continue;
    // hover pulse
    b.mesh.scale.setScalar(1+Math.sin(performance.now()*0.005)*0.03);
    // proximity + key E
    if(player.position.distanceTo(b.mesh.position)<1.8){
      // show ‚ÄúPress E‚Äù
      document.getElementById('status').textContent = `Press E to buy ${b.label} ($${fmt(b.cost)})`;
      if(keys['e']){
        if(spend(b.cost)){
          b.purchased=true;
          b.mesh.material.color.set(0x22c55e);
          b.sign.material.map = labelCanvas(`${b.label}\n‚úì Purchased`);
          b.onBuy?.();
          toast(`${b.label} purchased!`);
        } else {
          toast(`Need $${fmt(b.cost)}`);
        }
      }
    }
  }
}

// ---------- Save / Load ----------
function saveGame(){
  const s = JSON.stringify(state);
  localStorage.setItem('tycoon-save', s);
  toast('Saved!');
}
function loadGame(){
  const raw = localStorage.getItem('tycoon-save');
  if(!raw){ toast('No save found'); return; }
  try{
    // clear dynamic
    for(const c of conveyors) scene.remove(c.mesh);
    for(const d of droppers) scene.remove(d.mesh);
    if(collector) scene.remove(collector), collector=null;
    conveyors.length=0; droppers.length=0; items.forEach(it=>scene.remove(it.mesh)); items.length=0;
    buyPads.forEach(b=>scene.remove(b.mesh)); buyPads.length=0;
    floors.forEach((f,i)=>{ if(i>0&&f){ scene.remove(f); } });
    floors.length=1; floors[0]=base;

    state = JSON.parse(raw);

    // rebuild floors
    for(let lvl=2; lvl<=state.floorsUnlocked; lvl++) addUpperFloor(lvl);

    // rebuild conveyors/droppers/collector
    state.conveyors.forEach(c=> addConveyor(new THREE.Vector3(c.pos[0],c.pos[1],c.pos[2]), c.rotY));
    state.droppers.forEach(d=> addDropper(new THREE.Vector3(d.pos[0],d.pos[1],d.pos[2]), d.rotY, d.tier));
    if(state.hasCollector) addCollector(new THREE.Vector3(8,0,0));

    moneyEl.textContent = fmt(state.money);

    // rebuild buy pads
    buildBuyPads();

    toast('Loaded!');
  }catch(e){ console.error(e); toast('Failed to load'); }
}

document.getElementById('saveBtn').onclick=saveGame;
document.getElementById('loadBtn').onclick=loadGame;
document.getElementById('resetBtn').onclick=()=>{ localStorage.removeItem('tycoon-save'); location.reload(); };

// ---------- Initial Content ----------
function starterLayout(){
  // Starter conveyor & dropper to ‚Äúfeel‚Äù the loop
  addConveyor(new THREE.Vector3(-6,0.2,0), 0);
  addDropper(new THREE.Vector3(-8,0,0), 0, 1);
  // Place collector purchase pad and more
  buildBuyPads();
}

function buildBuyPads(){
  // Clear existing pads (for reload)
  buyPads.forEach(b=>scene.remove(b.mesh)); buyPads.length=0;

  // Base floor pads
  if(!state.hasCollector){
    addBuyPad(new THREE.Vector3(8,0.12,0), COST.collector, 'Collector', ()=>{
      addCollector(new THREE.Vector3(8,0,0));
    });
  }
  addBuyPad(new THREE.Vector3(-2,0.12,6), COST.conveyor, 'Conveyor', ()=>{
    addConveyor(new THREE.Vector3(-2,0.2,0), 0);
  });
  addBuyPad(new THREE.Vector3(-4,0.12,6), COST.dropper1, 'Dropper T1', ()=>{
    addDropper(new THREE.Vector3(-4,0,0), 0, 1);
  });
  addBuyPad(new THREE.Vector3(-6,0.12,6), COST.dropper2, 'Dropper T2', ()=>{
    addDropper(new THREE.Vector3(-6,0,0), 0, 2);
  });
  addBuyPad(new THREE.Vector3(-8,0.12,6), COST.dropper3, 'Dropper T3', ()=>{
    addDropper(new THREE.Vector3(-8,0,0), 0, 3);
  });

  // Upper floors pads (only show if not unlocked yet)
  if(state.floorsUnlocked<2){
    addBuyPad(new THREE.Vector3(10,0.12,8), COST.floor2, 'Unlock Floor 2', ()=>{
      state.floorsUnlocked=2; addUpperFloor(2); buildBuyPads();
    });
  } else if(state.floorsUnlocked<3){
    addBuyPad(new THREE.Vector3(10,5.12,8), COST.floor3, 'Unlock Floor 3', ()=>{
      state.floorsUnlocked=3; addUpperFloor(3); buildBuyPads();
    });
  } else {
    // Example pads on floor 2/3
    addBuyPad(new THREE.Vector3(-4,5.12,6), 400, 'Conveyor (F2)', ()=>{
      addConveyor(new THREE.Vector3(-4,5.2,0), 0);
    });
    addBuyPad(new THREE.Vector3(-6,10.12,6), 800, 'Dropper T2 (F3)', ()=>{
      addDropper(new THREE.Vector3(-6,10,0), 0, 2);
    });
  }
}

starterLayout();
moneyEl.textContent = fmt(state.money);

// ---------- Game Loop ----------
let last=performance.now();
function loop(now){
  const dt = Math.min(0.033, (now-last)/1000); last=now;

  updatePlayer(dt);
  updateDroppers(dt);
  updateItems(dt);
  updateParticles(dt);
  updateBuyPads(dt);

  renderer.render(scene, camera);
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// ---------- Resize ----------
window.addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
